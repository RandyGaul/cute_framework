// Seeds T_0: the base level of the ray interval hierarchy. Samples emissivity and
// absorption at each probe's target pixel to produce 1px ray intervals (radiance +
// transmittance).
//
// Pipeline:  seed -> [extend x N] -> merge -> composite
//            ^^^^
//
// At cascade 0, each probe has 2 directions:
//   v_0(0) = (1, -1)  diagonal down-right
//   v_0(1) = (1,  1)  diagonal up-right
//
// These two rays form the edges of a single cone covering the full +x quadrant
// (-pi/4 to pi/4). All higher cascade rays are built from these by the extend shader.
//
// The scene is sampled through a UV rotation so that all subsequent shaders (extend,
// merge, composite) operate purely in +x space without rotation awareness.
//
// Output buffer layout:
//   width  = world_size * 2  (world_size probes, 2 directions each)
//   height = world_size
//   index  = y * width + probe_x * 2 + k

layout(set = 0, binding = 0) uniform sampler2D u_emissivity;
layout(set = 0, binding = 1) uniform sampler2D u_absorption;

layout(std430, set = 1, binding = 0) writeonly buffer OutRad { uvec2 data[]; } u_out_rad;
layout(std430, set = 1, binding = 1) writeonly buffer OutTrn { uvec2 data[]; } u_out_trn;

layout(set = 2, binding = 0) uniform Params
{
	int u_rotate;     // 0..3 for each 90 degree quadrant.
	int u_world_size;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// A radiance interval stores accumulated radiance and transmittance along a ray segment.
// Radiance is premultiplied (already attenuated by absorption within the interval).
// Transmittance is the fraction of light that passes through the interval unabsorbed.
// Composable via merge() -- see Eq 9.
struct Interval
{
	vec3 rad;
	vec3 trn;
};

// Compose two intervals end-to-end (Eq 7, Sec 3).
//
//   Merge(⟨r_n, t_n⟩, ⟨r_f, t_f⟩) = ⟨r_n + t_n * r_f, t_n * t_f⟩
//
// Equivalent to premultiplied alpha compositing where transmittance = (1 - alpha).
Interval merge(Interval a, Interval b)
{
	return Interval(
		a.rad + a.trn * b.rad,
		a.trn * b.trn
	);
}

// Direction vector for the k-th ray at cascade n (Sec 4).
//
// At cascade n, probes are spaced 2^n apart in x. Each probe traces
// (2^n + 1) rays toward the next probe column. The k-th ray's endpoint
// has y-offset (2k - 2^n) from the probe, giving directions that span
// the full +/- pi/4 quadrant at every cascade level.
//
//   v_n(k) = (2^n, 2k - 2^n)
//
// At n=0: v_0(0) = (1, -1), v_0(1) = (1, 1)
// At n=1: v_1(0) = (2, -2), v_1(1) = (2, 0), v_1(2) = (2, 2)
vec2 v_n(int n, float k)
{
	float pow2n = float(1 << n);
	return vec2(pow2n, 2.0 * k - pow2n);
}

// Pack an Interval into a uvec2 pair (f16x4 each).
uvec2 f16_store(vec4 val)
{
	return uvec2(packHalf2x16(val.xy), packHalf2x16(val.zw));
}

vec3 linear_from_srgb(vec3 c)
{
	return pow(c, vec3(2.2));
}

// Transmittance through a single pixel of uniform absorption (Eq 2).
//
//   T(p, q) = exp(-sigma_t * d)
//
// The factor 4.0 is a tuning constant mapping the absorption texture
// value to optical depth per pixel-length ray.
vec3 calc_transmittance(vec3 a)
{
	return exp(-a * 4.0);
}

// Pre-rotate UV so the rest of HRC operates along the +x axis.
// Each of the 4 rotations (0..3) corresponds to a 90-degree quadrant.
vec2 rotate_uv(vec2 uv, int rot, float inv)
{
	if (rot == 1)      return vec2(inv - uv.y, uv.x);
	else if (rot == 2) return inv - uv;
	else if (rot == 3) return vec2(uv.y, inv - uv.x);
	return uv;
}

void main()
{
	// Cascade 0: 2 directions per probe, packed as (probe_x * 2 + k, probe_y).
	int cascade_w = u_world_size * 2;
	ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
	if (gid.x >= cascade_w || gid.y >= u_world_size) return;

	int probe_x = gid.x / 2;
	int k = gid.x % 2;

	float world = float(u_world_size);
	vec2 origin = vec2(float(probe_x), float(gid.y));
	vec2 target = origin + v_n(0, float(k));
	bool inbounds = target.x >= 0.0 && target.x < world && target.y >= 0.0 && target.y < world;

	// Rotate into world space for scene lookup.
	float inv = 1.0 - 1.0 / world;
	vec2 uv = rotate_uv(target / world, u_rotate, inv);

	vec3 emiss = linear_from_srgb(texture(u_emissivity, uv).rgb);
	vec3 absrp = linear_from_srgb(texture(u_absorption, uv).rgb);

	// Build the base interval for this ray (Eq 4 for uniform medium).
	//   L_r(p -> q) = L_e * (1 - T)
	// Radiance is premultiplied, ready for merge().
	vec3 trans = calc_transmittance(absrp);
	Interval iv = inbounds ? Interval(emiss * (vec3(1.0) - trans), trans) : Interval(vec3(0.0), vec3(1.0));

	int out_idx = gid.y * cascade_w + gid.x;
	u_out_rad.data[out_idx] = f16_store(vec4(iv.rad, 1.0));
	u_out_trn.data[out_idx] = f16_store(vec4(iv.trn, 1.0));
}
