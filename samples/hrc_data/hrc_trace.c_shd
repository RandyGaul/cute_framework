// Direct ray tracing for cascades 0-2 (replaces seed + extend at low levels).
//
// At low cascades, the extend shader's zigzag averaging of two diagonal candidates
// creates manhattan distance artifacts because c0 only has two diagonal directions
// (1,-1) and (1,1). This shader instead traces each ray directly using a column-by-
// column DDA: step one x-cell per iteration and split at y-cell boundaries so every
// cell the ray passes through is visited with its correct physical path length.
//
// Pipeline:  [trace x 3] -> [extend x (N-2)] -> merge -> composite
//            ^^^^^^^^^^^^
//
// Dispatched once per cascade level (0, 1, 2) per rotation. Uses the same buffer
// layout as seed/extend so the merge phase is unaffected.
//
// Output buffer layout (same as seed/extend):
//   width  = (world_size / 2^n) * (2^n + 1)
//   height = world_size
//   index  = y * width + probe_x * directions + k

layout(set = 0, binding = 0) uniform sampler2D u_emissivity;
layout(set = 0, binding = 1) uniform sampler2D u_absorption;

layout(std430, set = 1, binding = 0) writeonly buffer OutRad { uvec2 data[]; } u_out_rad;
layout(std430, set = 1, binding = 1) writeonly buffer OutTrn { uvec2 data[]; } u_out_trn;

layout(set = 2, binding = 0) uniform Params
{
	int u_cascade;
	int u_rotate;
	int u_world_size;
	int u_curr_w;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Interval
{
	vec3 rad;
	vec3 trn;
};

Interval merge(Interval a, Interval b)
{
	return Interval(
		a.rad + a.trn * b.rad,
		a.trn * b.trn
	);
}

// Direction vector for the k-th ray at cascade n (Sec 4).
//   v_n(k) = (2^n, 2k - 2^n)
vec2 v_n(int n, float k)
{
	float pow2n = float(1 << n);
	return vec2(pow2n, 2.0 * k - pow2n);
}

uvec2 f16_store(vec4 val)
{
	return uvec2(packHalf2x16(val.xy), packHalf2x16(val.zw));
}

vec3 linear_from_srgb(vec3 c)
{
	return pow(c, vec3(2.2));
}

// Pre-rotate UV so the rest of HRC operates along the +x axis.
vec2 rotate_uv(vec2 uv, int rot, float inv)
{
	if (rot == 1)      return vec2(inv - uv.y, uv.x);
	else if (rot == 2) return inv - uv;
	else if (rot == 3) return vec2(uv.y, inv - uv.x);
	return uv;
}

// Accumulate one cell's Beer-Lambert contribution along a ray.
// cell is the integer pixel coordinate; ds is the physical distance through the cell.
void trace_cell(vec2 cell, float ds, inout vec3 rad, inout vec3 trn)
{
	float world = float(u_world_size);
	if (cell.x < 0.0 || cell.x >= world || cell.y < 0.0 || cell.y >= world) return;
	vec2 uv = rotate_uv((cell + 0.5) / world, u_rotate, 1.0);
	vec3 emiss = linear_from_srgb(texture(u_emissivity, uv).rgb);
	vec3 absrp = linear_from_srgb(texture(u_absorption, uv).rgb);
	vec3 T = exp(-absrp * ds);
	rad += trn * emiss * (vec3(1.0) - T);
	trn *= T;
}

void main()
{
	int n = u_cascade;
	int pow2n = 1 << n;
	int directions = pow2n + 1;

	ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
	if (gid.x >= u_curr_w || gid.y >= u_world_size) return;

	int probe_x = gid.x / directions;
	int k = gid.x - probe_x * directions;

	// Ray direction and tracing parameters.
	vec2 delta = v_n(n, float(k));
	float max_comp = float(pow2n);             // max(|delta.x|, |delta.y|) = 2^n always
	vec2 slope = delta / max_comp;             // normalize so max component = 1
	float step_length = length(slope);         // physical distance per x-column step
	int num_steps = pow2n;                     // exactly 2^n x-columns

	// Probe origin in rotated world space.
	vec2 origin = vec2(float(probe_x) * float(pow2n), float(gid.y));
	float world = float(u_world_size);

	// Column-by-column DDA: one x-column per iteration. When the ray crosses a
	// y-cell boundary within a column, split the step so both cells get their
	// correct fractional path length through Beer-Lambert.
	vec3 acc_rad = vec3(0.0);
	vec3 acc_trn = vec3(1.0);

	float y_offset = 0.5;  // start at cell center so diagonal rays split symmetrically
	int cy = 0;            // current y-cell offset from int(origin.y)

	for (int s = 0; s < num_steps; s++) {
		float px = origin.x + float(s);
		if (px >= world) break;

		float next_y = 0.5 + slope.y * float(s + 1);
		int next_cy = int(floor(next_y));

		vec2 col = vec2(px, origin.y);

		if (cy == next_cy) {
			// No y-boundary crossing -- full step in one cell.
			trace_cell(col + vec2(0, float(cy)), step_length, acc_rad, acc_trn);
		} else {
			// Y-boundary crossed -- split into two sub-steps.
			float y_bound = slope.y > 0.0 ? float(cy + 1) : float(cy);
			float frac = (y_bound - y_offset) / slope.y;
			trace_cell(col + vec2(0, float(cy)), frac * step_length, acc_rad, acc_trn);
			trace_cell(col + vec2(0, float(next_cy)), (1.0 - frac) * step_length, acc_rad, acc_trn);
		}

		y_offset = next_y;
		cy = next_cy;
	}

	int out_idx = gid.y * u_curr_w + gid.x;
	u_out_rad.data[out_idx] = f16_store(vec4(acc_rad, 1.0));
	u_out_trn.data[out_idx] = f16_store(vec4(acc_trn, 1.0));
}
