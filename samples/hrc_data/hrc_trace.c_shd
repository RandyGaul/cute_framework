// Direct ray tracing for cascades 0-2 (replaces seed + extend at low levels).
//
// At low cascades, the extend shader's zigzag averaging of two diagonal candidates
// creates manhattan distance artifacts because c0 only has two diagonal directions
// (1,-1) and (1,1). This shader instead traces each ray directly using a line-slope
// method: exactly N = 2^n pixel steps per ray, with step_length weighting to account
// for diagonal rays being physically longer than axis-aligned ones.
//
// Pipeline:  [trace x 3] -> [extend x (N-2)] -> merge -> composite
//            ^^^^^^^^^^^^
//
// Dispatched once per cascade level (0, 1, 2) per rotation. Uses the same buffer
// layout as seed/extend so the merge phase is unaffected.
//
// Output buffer layout (same as seed/extend):
//   width  = (world_size / 2^n) * (2^n + 1)
//   height = world_size
//   index  = y * width + probe_x * directions + k

layout(set = 0, binding = 0) uniform sampler2D u_emissivity;
layout(set = 0, binding = 1) uniform sampler2D u_absorption;

layout(std430, set = 1, binding = 0) writeonly buffer OutRad { uvec2 data[]; } u_out_rad;
layout(std430, set = 1, binding = 1) writeonly buffer OutTrn { uvec2 data[]; } u_out_trn;

layout(set = 2, binding = 0) uniform Params
{
	int u_cascade;
	int u_rotate;
	int u_world_size;
	int u_curr_w;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Interval
{
	vec3 rad;
	vec3 trn;
};

Interval merge(Interval a, Interval b)
{
	return Interval(
		a.rad + a.trn * b.rad,
		a.trn * b.trn
	);
}

// Direction vector for the k-th ray at cascade n (Sec 4).
//   v_n(k) = (2^n, 2k - 2^n)
vec2 v_n(int n, float k)
{
	float pow2n = float(1 << n);
	return vec2(pow2n, 2.0 * k - pow2n);
}

uvec2 f16_store(vec4 val)
{
	return uvec2(packHalf2x16(val.xy), packHalf2x16(val.zw));
}

vec3 linear_from_srgb(vec3 c)
{
	return pow(c, vec3(2.2));
}

// Pre-rotate UV so the rest of HRC operates along the +x axis.
vec2 rotate_uv(vec2 uv, int rot, float inv)
{
	if (rot == 1)      return vec2(inv - uv.y, uv.x);
	else if (rot == 2) return inv - uv;
	else if (rot == 3) return vec2(uv.y, inv - uv.x);
	return uv;
}

void main()
{
	int n = u_cascade;
	int pow2n = 1 << n;
	int directions = pow2n + 1;

	ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
	if (gid.x >= u_curr_w || gid.y >= u_world_size) return;

	int probe_x = gid.x / directions;
	int k = gid.x - probe_x * directions;

	// Ray direction and tracing parameters.
	vec2 delta = v_n(n, float(k));
	float max_comp = float(pow2n);             // max(|delta.x|, |delta.y|) = 2^n always
	vec2 slope = delta / max_comp;             // normalize so max component = 1
	float step_length = length(slope);         // > 1.0 for diagonal rays
	int num_steps = pow2n;                     // exactly 2^n pixel steps

	// Probe origin in rotated world space.
	vec2 origin = vec2(float(probe_x) * float(pow2n), float(gid.y));
	float world = float(u_world_size);
	float inv = 1.0;

	// Trace exactly num_steps pixels along the ray.
	vec3 acc_rad = vec3(0.0);
	vec3 acc_trn = vec3(1.0);

	for (int s = 0; s < num_steps; s++) {
		vec2 pos = origin + slope * (float(s) + 1.0);

		// Bounds check â€” out-of-bounds contributes (rad=0, trn=1), no change.
		if (pos.x < 0.0 || pos.x >= world || pos.y < 0.0 || pos.y >= world) continue;

		vec2 uv = rotate_uv((pos + 0.5) / world, u_rotate, inv);

		vec3 emiss = linear_from_srgb(texture(u_emissivity, uv).rgb);
		vec3 absrp = linear_from_srgb(texture(u_absorption, uv).rgb);

		// step_length accounts for diagonal rays traversing more material per pixel.
		vec3 optical_depth = absrp * step_length;
		vec3 transmittance = exp(-optical_depth);
		vec3 radiance = emiss * (vec3(1.0) - transmittance);

		acc_rad += radiance * acc_trn;
		acc_trn *= transmittance;
	}

	int out_idx = gid.y * u_curr_w + gid.x;
	u_out_rad.data[out_idx] = f16_store(vec4(acc_rad, 1.0));
	u_out_trn.data[out_idx] = f16_store(vec4(acc_trn, 1.0));
}
