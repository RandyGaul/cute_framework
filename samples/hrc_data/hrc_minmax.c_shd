// Compute per-grid-cell min/max absorption luminance.
//
// For each grid cell, loops over the SxS world pixels it covers
// (S = world_size / grid_size), computes min/max absorption luminance,
// and writes to a rg16f storage image. The composite shader uses this
// to blend between bilinear (smooth areas) and nearest-neighbor (edges)
// when upscaling R_0 from grid to world resolution.
//
// Pipeline:  [trace] -> [extend] -> [merge] -> minmax -> [composite]
//                                               ^^^^^^

layout(set = 0, binding = 0) uniform sampler2D u_absorption;
layout(set = 1, binding = 0, rg16f) uniform writeonly image2D u_minmax;

layout(set = 2, binding = 0) uniform Params
{
	int u_world_size;
	int u_grid_size;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main()
{
	ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
	if (gid.x >= u_grid_size || gid.y >= u_grid_size) return;

	int S = u_world_size / u_grid_size;
	ivec2 base = gid * S;
	float world = float(u_world_size);

	float mn = 1e10;
	float mx = 0.0;

	for (int dy = 0; dy < S; dy++) {
		for (int dx = 0; dx < S; dx++) {
			ivec2 p = base + ivec2(dx, dy);
			vec2 uv = (vec2(p) + 0.5) / world;
			vec3 a = texture(u_absorption, uv).rgb;
			float lum = dot(a, vec3(0.333));
			mn = min(mn, lum);
			mx = max(mx, lum);
		}
	}

	imageStore(u_minmax, gid, vec4(mn, mx, 0.0, 0.0));
}
