// Mipmap-style box-average absorption luminance per grid cell, at world resolution.
//
// Dispatched at world_size x world_size. Each world pixel determines which
// grid cell it belongs to, averages the absorption luminance over all SxS
// world pixels in that cell, and writes the result to its own position.
// All world pixels in the same grid cell write the same average value.
//
// The composite shader compares averages between neighboring cells to detect
// absorption edges. This is smoother than min/max range, which spikes at
// any single wall pixel in a cell.
//
// Pipeline:  [trace] -> [extend] -> [merge] -> mipmap -> [composite]
//                                               ^^^^^^

layout(set = 0, binding = 0) uniform sampler2D u_absorption;
layout(set = 1, binding = 0, rg16f) uniform writeonly image2D u_minmax;

layout(set = 2, binding = 0) uniform Params
{
	int u_world_size;
	int u_grid_size;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main()
{
	ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
	if (gid.x >= u_world_size || gid.y >= u_world_size) return;

	int S = u_world_size / u_grid_size;
	ivec2 grid_cell = gid / S;
	ivec2 base = grid_cell * S;
	float world = float(u_world_size);

	float total = 0.0;
	for (int dy = 0; dy < S; dy++) {
		for (int dx = 0; dx < S; dx++) {
			ivec2 p = base + ivec2(dx, dy);
			vec2 uv = (vec2(p) + 0.5) / world;
			vec3 a = texture(u_absorption, uv).rgb;
			total += dot(a, vec3(0.333));
		}
	}

	float avg = total / float(S * S);
	imageStore(u_minmax, gid, vec4(avg, 0.0, 0.0, 0.0));
}
