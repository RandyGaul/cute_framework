// Sum 4 quadrants with c-1 gathering, cross blur, output (Sec 4.2, Eq 21).
//
// Each quadrant's R_0 was computed in +x-aligned space by the merge-down phase
// and stored in F_0..F_3. This shader reverses the rotation, raymarches a c-1
// interval per quadrant toward the nearest c0 probe to bridge the gap between the
// pixel and the R_0 probe at +1 offset, merges c-1 with R_0, applies the cross
// blur to remove checkerboard artifacts, and writes the final fluence.
//
// The cascade grid (u_grid_size) may be smaller than the output (u_world_size).
// Frustum buffers are grid-sized; the output fluence and scene textures are world-sized.
// c-1 sampling at world resolution provides per-pixel detail even when upscaling.
//
// Pipeline:  [trace x 3] -> [extend x (N-2)] -> [merge x N] -> composite
//                                                               ^^^^^^^^^
// Inputs:
//   u_emissivity   — scene emissivity (for c-1 trace)
//   u_absorption   — scene absorption (for c-1 trace + cross blur opacity test)
//   u_f0..u_f3     — R_0 per quadrant (grid_size x grid_size, uvec2 f16)
//
// Outputs:
//   u_fluence      — final fluence image (rgba8, world_size x world_size)

layout(set = 0, binding = 0) uniform sampler2D u_emissivity;
layout(set = 0, binding = 1) uniform sampler2D u_absorption;
layout(std430, set = 0, binding = 2) readonly buffer F0 { uvec2 data[]; } u_f0;
layout(std430, set = 0, binding = 3) readonly buffer F1 { uvec2 data[]; } u_f1;
layout(std430, set = 0, binding = 4) readonly buffer F2 { uvec2 data[]; } u_f2;
layout(std430, set = 0, binding = 5) readonly buffer F3 { uvec2 data[]; } u_f3;
layout(set = 1, binding = 0, rgba8) uniform writeonly image2D u_fluence;

layout(set = 2, binding = 0) uniform Params
{
	int   u_world_size;    // output resolution (e.g. 512)
	int   u_grid_size;     // cascade grid resolution (e.g. 256)
	float u_abs_threshold; // opacity similarity cutoff for cross blur
	int   u_debug_mode;
	int   u_cminus1;      // 0 = skip c-1 gathering, 1 = raymarch c-1
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Interval
{
	vec3 rad;
	vec3 trn;
};

vec4 f16_load(uvec2 packed)
{
	return vec4(unpackHalf2x16(packed.x), unpackHalf2x16(packed.y));
}

vec3 srgb_from_linear(vec3 c)
{
	return pow(c, vec3(1.0 / 2.2));
}

vec3 linear_from_srgb(vec3 c)
{
	return pow(c, vec3(2.2));
}

// Inverse of seed's rotate_uv, in integer pixel space.
// Operates in grid-space coordinates (grid_size x grid_size).
//
// Seed forward (rotated -> world):
//   rot 0: (rx, ry) -> (rx, ry)
//   rot 1: (rx, ry) -> (s-ry, rx)
//   rot 2: (rx, ry) -> (s-rx, s-ry)
//   rot 3: (rx, ry) -> (ry, s-rx)
//
// Inverse (world -> rotated):
ivec2 grid_to_rotated(ivec2 p, int rot, int s)
{
	if (rot == 1) return ivec2(p.y, s - p.x);
	if (rot == 2) return ivec2(s - p.x, s - p.y);
	if (rot == 3) return ivec2(s - p.y, p.x);
	return p;
}

// Load fluence from one quadrant's F buffer at a rotated grid coordinate.
// No offset applied here -- caller is responsible for the +1 shift.
vec3 F_load(int rot, ivec2 rotated_pos)
{
	if (rotated_pos.x < 0 || rotated_pos.x >= u_grid_size || rotated_pos.y < 0 || rotated_pos.y >= u_grid_size) return vec3(0.0);
	int idx = rotated_pos.y * u_grid_size + rotated_pos.x;
	vec4 val;
	if      (rot == 0) val = f16_load(u_f0.data[idx]);
	else if (rot == 1) val = f16_load(u_f1.data[idx]);
	else if (rot == 2) val = f16_load(u_f2.data[idx]);
	else               val = f16_load(u_f3.data[idx]);
	return val.rgb;
}

// World-space march direction for each quadrant's rotated +x axis.
//   rot 0: +x in rotated -> +x in world
//   rot 1: +x in rotated -> +y in world
//   rot 2: +x in rotated -> -x in world
//   rot 3: +x in rotated -> -y in world
ivec2 quadrant_dir(int rot)
{
	if (rot == 1) return ivec2(0, 1);
	if (rot == 2) return ivec2(-1, 0);
	if (rot == 3) return ivec2(0, -1);
	return ivec2(1, 0);
}

// Raymarch c-1 interval from the current pixel toward the nearest c0 probe.
// Covers the gap between the pixel and the R_0 probe at +1 grid offset in
// the quadrant's +x direction. The result is NOT stored in cascade memory.
//
// With upscaling (world_size > grid_size), the probe is S = world_size/grid_size
// world pixels away from the grid cell origin. The march steps through each
// intervening world pixel, accumulating emission and transmittance via Beer's law.
// At 1x (no upscaling) this reduces to a single-pixel tap matching c0 probe spacing.
Interval trace_cminus1(ivec2 world_pos, int rot)
{
	int S = u_world_size / u_grid_size;
	ivec2 dir = quadrant_dir(rot);

	// Effective coordinate along the march direction (increases toward the probe).
	int pos_along;
	if      (rot == 0) pos_along = world_pos.x;
	else if (rot == 1) pos_along = world_pos.y;
	else if (rot == 2) pos_along = (u_world_size - 1) - world_pos.x;
	else               pos_along = (u_world_size - 1) - world_pos.y;

	// Exact number of world pixels from here to the c0 probe at +1 grid offset.
	int grid_along = pos_along * u_grid_size / u_world_size;
	int num_steps = (grid_along + 1) * S - pos_along;

	float world = float(u_world_size);
	float step_abs = 4.0 / float(S);

	vec3 acc_rad = vec3(0.0);
	vec3 acc_trn = vec3(1.0);

	for (int i = 0; i < num_steps; i++) {
		ivec2 p = world_pos + dir * i;
		vec2 uv = (vec2(p) + 0.5) / world;

		vec3 emiss = linear_from_srgb(texture(u_emissivity, uv).rgb);
		vec3 absrp = linear_from_srgb(texture(u_absorption, uv).rgb);

		vec3 trans = exp(-absrp * step_abs);
		acc_rad += acc_trn * emiss * (vec3(1.0) - trans);
		acc_trn *= trans;
	}

	return Interval(acc_rad, acc_trn);
}

// Sum fluence from all 4 quadrants at a world-space pixel, with c-1 gathering.
// Each quadrant covers one 90 degree wedge of the full 2pi.
//
// Maps world_pos to the grid, rotates into each quadrant's space to read R_0,
// then merges with a c-1 interval sampled at full world resolution.
vec3 sum_quadrants(ivec2 world_pos)
{
	int s = u_grid_size - 1;
	ivec2 grid_pos = world_pos * u_grid_size / u_world_size;
	vec3 total = vec3(0.0);
	for (int rot = 0; rot < 4; rot++) {
		ivec2 rp = grid_to_rotated(grid_pos, rot, s);
		vec3 r0 = F_load(rot, rp + ivec2(1, 0));
		if (u_cminus1 != 0) {
			Interval cminus1 = trace_cminus1(world_pos, rot);
			total += cminus1.rad + cminus1.trn * r0;
		} else {
			total += r0;
		}
	}
	return total;
}

// Read absorption magnitude at a world pixel for the opacity similarity check.
float absorption_at(ivec2 pos)
{
	float world = float(u_world_size);
	vec2 uv = (vec2(pos) + 0.5) / world;
	vec3 a = texture(u_absorption, uv).rgb;
	return dot(a, vec3(0.333));
}

// Accumulate a weighted blur tap, skipping out-of-bounds pixels and
// pixels whose absorption differs significantly from the center.
void blur_tap(ivec2 np, float w, float center_abs, inout vec3 sum, inout float weight)
{
	if (np.x < 0 || np.x >= u_world_size || np.y < 0 || np.y >= u_world_size) return;
	if (abs(absorption_at(np) - center_abs) > u_abs_threshold) return;
	sum += sum_quadrants(np) * w;
	weight += w;
}

// 5x5 Gaussian blur to remove checkerboard artifacts.
//
//   K = [1 4 6 4 1; 4 16 24 16 4; 6 24 36 24 6; 4 16 24 16 4; 1 4 6 4 1] / 256
//
// Skips neighbors that differ significantly in absorption from
// the center pixel, preventing light leaking through walls.
// When taps are skipped, the total weight is reduced so the
// remaining taps are renormalized.
//
// The checkerboard arises because v_n(k) has even y-offsets for
// n >= 1, so odd and even y-rows never interact during extend/merge.
// At 2x upscaling, the checkerboard is 2 world pixels wide, requiring
// a 5x5 kernel to fully smooth it.
vec3 blur_5x5(ivec2 pos)
{
	float center_abs = absorption_at(pos);
	vec3 sum = sum_quadrants(pos) * 36.0;
	float weight = 36.0;

	// Distance 1: cardinal (weight 24), diagonal (weight 16)
	blur_tap(pos + ivec2(-1,  0), 24.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 1,  0), 24.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 0, -1), 24.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 0,  1), 24.0, center_abs, sum, weight);
	blur_tap(pos + ivec2(-1, -1), 16.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 1, -1), 16.0, center_abs, sum, weight);
	blur_tap(pos + ivec2(-1,  1), 16.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 1,  1), 16.0, center_abs, sum, weight);

	// Distance 2: cardinal (weight 6), semi-diagonal (weight 4), corner (weight 1)
	blur_tap(pos + ivec2(-2,  0),  6.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 2,  0),  6.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 0, -2),  6.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 0,  2),  6.0, center_abs, sum, weight);
	blur_tap(pos + ivec2(-2, -1),  4.0, center_abs, sum, weight);
	blur_tap(pos + ivec2(-2,  1),  4.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 2, -1),  4.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 2,  1),  4.0, center_abs, sum, weight);
	blur_tap(pos + ivec2(-1, -2),  4.0, center_abs, sum, weight);
	blur_tap(pos + ivec2(-1,  2),  4.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 1, -2),  4.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 1,  2),  4.0, center_abs, sum, weight);
	blur_tap(pos + ivec2(-2, -2),  1.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 2, -2),  1.0, center_abs, sum, weight);
	blur_tap(pos + ivec2(-2,  2),  1.0, center_abs, sum, weight);
	blur_tap(pos + ivec2( 2,  2),  1.0, center_abs, sum, weight);

	return sum / weight;
}

void main()
{
	ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
	if (gid.x >= u_world_size || gid.y >= u_world_size) return;

	vec3 fluence;
	if (u_debug_mode >= 1 && u_debug_mode <= 4) {
		// Show a single quadrant, no blur.
		int rot = u_debug_mode - 1;
		int s = u_grid_size - 1;
		ivec2 grid_pos = gid * u_grid_size / u_world_size;
		ivec2 rp = grid_to_rotated(grid_pos, rot, s);
		vec3 r0 = F_load(rot, rp + ivec2(1, 0));
		if (u_cminus1 != 0) {
			Interval cminus1 = trace_cminus1(gid, rot);
			fluence = cminus1.rad + cminus1.trn * r0;
		} else {
			fluence = r0;
		}
	} else if (u_debug_mode == 5) {
		// Sum all quadrants with c-1 gathering, no blur.
		fluence = sum_quadrants(gid);
	} else {
		fluence = blur_5x5(gid);
	}

	imageStore(u_fluence, gid, vec4(srgb_from_linear(fluence), 1.0));
}
