// Sum 4 quadrants with c-1 gathering, cross blur, output (Sec 4.2, Eq 21).
//
// Each quadrant's R_0 was computed in +x-aligned space by the merge-down phase
// and stored in F_0..F_3. This shader reverses the rotation, raymarches a c-1
// interval per quadrant toward the nearest c0 probe to bridge the gap between the
// pixel and the R_0 probe at +1 offset, merges c-1 with R_0, applies the cross
// blur to remove checkerboard artifacts, and writes the final fluence.
//
// The cascade grid (u_grid_size) may be smaller than the output (u_world_size).
// Frustum buffers are grid-sized; the output fluence and scene textures are world-sized.
// c-1 sampling at world resolution provides per-pixel detail even when upscaling.
//
// Pipeline:  [trace x 3] -> [extend x (N-2)] -> [merge x N] -> composite
//                                                               ^^^^^^^^^
// Inputs:
//   u_emissivity   — scene emissivity (for c-1 trace)
//   u_absorption   — scene absorption (for c-1 trace + cross blur opacity test)
//   u_f0..u_f3     — R_0 per quadrant (grid_size x grid_size, uvec2 f16)
//
// Outputs:
//   u_fluence      — final fluence image (rgba8, world_size x world_size)

layout(set = 0, binding = 0) uniform sampler2D u_emissivity;
layout(set = 0, binding = 1) uniform sampler2D u_absorption;
layout(set = 0, binding = 2) uniform sampler2D u_minmax;
layout(std430, set = 0, binding = 3) readonly buffer F0 { uvec2 data[]; } u_f0;
layout(std430, set = 0, binding = 4) readonly buffer F1 { uvec2 data[]; } u_f1;
layout(std430, set = 0, binding = 5) readonly buffer F2 { uvec2 data[]; } u_f2;
layout(std430, set = 0, binding = 6) readonly buffer F3 { uvec2 data[]; } u_f3;
layout(set = 1, binding = 0, rgba8) uniform writeonly image2D u_fluence;

layout(set = 2, binding = 0) uniform Params
{
	int   u_world_size;    // output resolution (e.g. 512)
	int   u_grid_size;     // cascade grid resolution (e.g. 256)
	float u_abs_threshold; // opacity similarity cutoff for cross blur
	int   u_debug_mode;
	int   u_cminus1;       // 0 = skip c-1 gathering, 1 = raymarch c-1
	int   u_upscale_mode;  // 0 = nearest, 1 = minmax bilinear, 2 = joint bilateral
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Interval
{
	vec3 rad;
	vec3 trn;
};

vec4 f16_load(uvec2 packed)
{
	return vec4(unpackHalf2x16(packed.x), unpackHalf2x16(packed.y));
}

vec3 srgb_from_linear(vec3 c)
{
	return pow(c, vec3(1.0 / 2.2));
}

vec3 linear_from_srgb(vec3 c)
{
	return pow(c, vec3(2.2));
}

// Inverse of seed's rotate_uv, in integer pixel space.
// Operates in grid-space coordinates (grid_size x grid_size).
//
// Seed forward (rotated -> world):
//   rot 0: (rx, ry) -> (rx, ry)
//   rot 1: (rx, ry) -> (s-ry, rx)
//   rot 2: (rx, ry) -> (s-rx, s-ry)
//   rot 3: (rx, ry) -> (ry, s-rx)
//
// Inverse (world -> rotated):
ivec2 grid_to_rotated(ivec2 p, int rot, int s)
{
	if (rot == 1) return ivec2(p.y, s - p.x);
	if (rot == 2) return ivec2(s - p.x, s - p.y);
	if (rot == 3) return ivec2(s - p.y, p.x);
	return p;
}

// Load fluence from one quadrant's F buffer at a rotated grid coordinate.
// No offset applied here -- caller is responsible for the +1 shift.
vec3 F_load(int rot, ivec2 rotated_pos)
{
	if (rotated_pos.x < 0 || rotated_pos.x >= u_grid_size || rotated_pos.y < 0 || rotated_pos.y >= u_grid_size) return vec3(0.0);
	int idx = rotated_pos.y * u_grid_size + rotated_pos.x;
	vec4 val;
	if      (rot == 0) val = f16_load(u_f0.data[idx]);
	else if (rot == 1) val = f16_load(u_f1.data[idx]);
	else if (rot == 2) val = f16_load(u_f2.data[idx]);
	else               val = f16_load(u_f3.data[idx]);
	return val.rgb;
}

// World-space march direction for each quadrant's rotated +x axis.
//   rot 0: +x in rotated -> +x in world
//   rot 1: +x in rotated -> +y in world
//   rot 2: +x in rotated -> -x in world
//   rot 3: +x in rotated -> -y in world
ivec2 quadrant_dir(int rot)
{
	if (rot == 1) return ivec2(0, 1);
	if (rot == 2) return ivec2(-1, 0);
	if (rot == 3) return ivec2(0, -1);
	return ivec2(1, 0);
}

// Raymarch c-1 interval from the current pixel toward the nearest c0 probe.
// Covers the gap between the pixel and the R_0 probe at +1 grid offset in
// the quadrant's +x direction. The result is NOT stored in cascade memory.
//
// With upscaling (world_size > grid_size), the probe is S = world_size/grid_size
// world pixels away from the grid cell origin. The march steps through each
// intervening world pixel, accumulating emission and transmittance via Beer's law.
// At 1x (no upscaling) this reduces to a single-pixel tap matching c0 probe spacing.
Interval trace_cminus1(ivec2 world_pos, int rot)
{
	int S = u_world_size / u_grid_size;
	ivec2 dir = quadrant_dir(rot);

	// Effective coordinate along the march direction (increases toward the probe).
	int pos_along;
	if      (rot == 0) pos_along = world_pos.x;
	else if (rot == 1) pos_along = world_pos.y;
	else if (rot == 2) pos_along = (u_world_size - 1) - world_pos.x;
	else               pos_along = (u_world_size - 1) - world_pos.y;

	// Exact number of world pixels from here to the c0 probe at +1 grid offset.
	int grid_along = pos_along * u_grid_size / u_world_size;
	int num_steps = (grid_along + 1) * S - pos_along;

	float world = float(u_world_size);
	float step_abs = 1.0 / float(S);

	vec3 acc_rad = vec3(0.0);
	vec3 acc_trn = vec3(1.0);

	for (int i = 0; i < num_steps; i++) {
		ivec2 p = world_pos + dir * i;
		vec2 uv = (vec2(p) + 0.5) / world;

		vec3 emiss = linear_from_srgb(texture(u_emissivity, uv).rgb);
		vec3 absrp = linear_from_srgb(texture(u_absorption, uv).rgb);

		vec3 trans = exp(-absrp * step_abs);
		acc_rad += acc_trn * emiss * (vec3(1.0) - trans);
		acc_trn *= trans;
	}

	return Interval(acc_rad, acc_trn);
}

// Read min/max absorption from the world-resolution minmax texture.
// Takes a grid position, converts to a world coordinate for the fetch.
// All world pixels in the same grid cell store the same value.
vec2 minmax_at(ivec2 grid_pos)
{
	grid_pos = clamp(grid_pos, ivec2(0), ivec2(u_grid_size - 1));
	int S = u_world_size / u_grid_size;
	return texelFetch(u_minmax, grid_pos * S, 0).rg;
}

// Read absorption magnitude at a world pixel for the opacity similarity check.
float absorption_at(ivec2 pos)
{
	float world = float(u_world_size);
	vec2 uv = (vec2(pos) + 0.5) / world;
	vec3 a = texture(u_absorption, uv).rgb;
	return dot(a, vec3(0.333));
}

// Sum fluence from all 4 quadrants at a world-space pixel, with c-1 gathering.
// Each quadrant covers one 90 degree wedge of the full 2pi.
//
// Maps world_pos to the grid, rotates into each quadrant's space to read R_0,
// then merges with a c-1 interval sampled at full world resolution.
//
// Upscale modes (u_upscale_mode):
//   0 = nearest-neighbor
//   1 = minmax bilinear: bilinear in smooth areas, nearest at absorption edges
//   2 = joint bilateral: bilinear weighted by absorption similarity at each probe
vec3 sum_quadrants(ivec2 world_pos)
{
	int s = u_grid_size - 1;
	ivec2 grid_pos = world_pos * u_grid_size / u_world_size;

	// Interpolation state (shared by minmax and bilateral paths).
	vec2 fgrid;
	ivec2 g0;
	vec2 frac_pos;
	float blend = 0.0;        // minmax: 0=nearest, 1=bilinear
	float bw00 = 1.0, bw10 = 1.0, bw01 = 1.0, bw11 = 1.0; // bilateral weights

	if (u_upscale_mode != 0 && u_world_size > u_grid_size) {
		fgrid = vec2(world_pos) * float(u_grid_size) / float(u_world_size) - 0.5;
		g0 = ivec2(floor(fgrid));
		frac_pos = fract(fgrid);

		if (u_upscale_mode == 1) {
			// Minmax: check absorption range across neighboring grid cells.
			float max_range = 0.0;
			for (int dy = 0; dy <= 1; dy++) {
				for (int dx = 0; dx <= 1; dx++) {
					vec2 mm = minmax_at(g0 + ivec2(dx, dy));
					max_range = max(max_range, mm.g - mm.r);
				}
			}
			blend = 1.0 - smoothstep(0.0, u_abs_threshold, max_range);
		} else if (u_upscale_mode == 2) {
			// Joint bilateral: weight probes by absorption similarity.
			blend = 1.0;
			float center_abs = absorption_at(world_pos);
			int S = u_world_size / u_grid_size;
			float sigma = max(u_abs_threshold, 0.01);
			float inv_2s2 = 1.0 / (2.0 * sigma * sigma);

			// Absorption at each probe's world position (center of grid cell).
			float d00 = absorption_at(clamp(g0,              ivec2(0), ivec2(s)) * S + S / 2) - center_abs;
			float d10 = absorption_at(clamp(g0 + ivec2(1,0), ivec2(0), ivec2(s)) * S + S / 2) - center_abs;
			float d01 = absorption_at(clamp(g0 + ivec2(0,1), ivec2(0), ivec2(s)) * S + S / 2) - center_abs;
			float d11 = absorption_at(clamp(g0 + ivec2(1,1), ivec2(0), ivec2(s)) * S + S / 2) - center_abs;

			bw00 = exp(-d00 * d00 * inv_2s2);
			bw10 = exp(-d10 * d10 * inv_2s2);
			bw01 = exp(-d01 * d01 * inv_2s2);
			bw11 = exp(-d11 * d11 * inv_2s2);
		}
	}

	vec3 total = vec3(0.0);
	for (int rot = 0; rot < 4; rot++) {
		vec3 r0;

		if (blend > 0.0) {
			// Load R_0 from 4 neighboring grid probes.
			vec3 r00 = F_load(rot, grid_to_rotated(clamp(g0,              ivec2(0), ivec2(s)), rot, s) + ivec2(1, 0));
			vec3 r10 = F_load(rot, grid_to_rotated(clamp(g0 + ivec2(1,0), ivec2(0), ivec2(s)), rot, s) + ivec2(1, 0));
			vec3 r01 = F_load(rot, grid_to_rotated(clamp(g0 + ivec2(0,1), ivec2(0), ivec2(s)), rot, s) + ivec2(1, 0));
			vec3 r11 = F_load(rot, grid_to_rotated(clamp(g0 + ivec2(1,1), ivec2(0), ivec2(s)), rot, s) + ivec2(1, 0));

			if (u_upscale_mode == 2) {
				// Joint bilateral: spatial bilinear * absorption similarity.
				float w00 = (1.0 - frac_pos.x) * (1.0 - frac_pos.y) * bw00;
				float w10 = frac_pos.x           * (1.0 - frac_pos.y) * bw10;
				float w01 = (1.0 - frac_pos.x) * frac_pos.y           * bw01;
				float w11 = frac_pos.x           * frac_pos.y           * bw11;
				float wt = w00 + w10 + w01 + w11;
				if (wt > 0.001) {
					r0 = (r00 * w00 + r10 * w10 + r01 * w01 + r11 * w11) / wt;
				} else {
					// All probes dissimilar — fall back to nearest.
					ivec2 rp = grid_to_rotated(grid_pos, rot, s);
					r0 = F_load(rot, rp + ivec2(1, 0));
				}
			} else {
				// Minmax bilinear.
				vec3 r0_bilinear = mix(mix(r00, r10, frac_pos.x), mix(r01, r11, frac_pos.x), frac_pos.y);
				if (blend < 1.0) {
					ivec2 rp = grid_to_rotated(grid_pos, rot, s);
					vec3 r0_nearest = F_load(rot, rp + ivec2(1, 0));
					r0 = mix(r0_nearest, r0_bilinear, blend);
				} else {
					r0 = r0_bilinear;
				}
			}
		} else {
			// Pure nearest-neighbor.
			ivec2 rp = grid_to_rotated(grid_pos, rot, s);
			r0 = F_load(rot, rp + ivec2(1, 0));
		}

		// c-1 gathering: trace to nearest probe, merge with (possibly interpolated) R_0.
		if (u_cminus1 != 0) {
			Interval cminus1 = trace_cminus1(world_pos, rot);
			total += cminus1.rad + cminus1.trn * r0;
		} else {
			total += r0;
		}
	}
	return total;
}

// Shared memory tile for precomputed sum_quadrants results.
// 16x16 workgroup + 1-pixel blur halo on each side = 18x18 tile.
// Precomputing avoids calling sum_quadrants 9x per pixel inside
// the blur, which causes shader compilation timeouts on some drivers.
#define BLUR_R 1
#define TILE_W (16 + 2 * BLUR_R)
shared vec3 s_tile[TILE_W * TILE_W];

// Accumulate a blur tap from the shared memory tile, skipping
// out-of-bounds pixels and absorption discontinuities.
void tile_tap(ivec2 offset, float w, float center_abs, ivec2 world_center, ivec2 tc, inout vec3 sum, inout float weight)
{
	ivec2 np = world_center + offset;
	if (np.x < 0 || np.x >= u_world_size || np.y < 0 || np.y >= u_world_size) return;
	if (abs(absorption_at(np) - center_abs) > u_abs_threshold) return;
	ivec2 t = tc + offset;
	sum += s_tile[t.y * TILE_W + t.x] * w;
	weight += w;
}

// 3x3 cross blur from the HRC paper.
//
//   K = [1 2 1; 2 4 2; 1 2 1] / 16
//
// Skips neighbors that differ significantly in absorption from
// the center pixel, preventing light leaking through walls.
// When taps are skipped, the total weight is reduced so the
// remaining taps are renormalized.
vec3 blur_tile(ivec2 pos, ivec2 tc)
{
	float center_abs = absorption_at(pos);
	vec3 sum = s_tile[tc.y * TILE_W + tc.x] * 4.0;
	float weight = 4.0;

	// Cardinal neighbors (weight 2)
	tile_tap(ivec2(-1,  0), 2.0, center_abs, pos, tc, sum, weight);
	tile_tap(ivec2( 1,  0), 2.0, center_abs, pos, tc, sum, weight);
	tile_tap(ivec2( 0, -1), 2.0, center_abs, pos, tc, sum, weight);
	tile_tap(ivec2( 0,  1), 2.0, center_abs, pos, tc, sum, weight);

	// Diagonal neighbors (weight 1)
	tile_tap(ivec2(-1, -1), 1.0, center_abs, pos, tc, sum, weight);
	tile_tap(ivec2( 1, -1), 1.0, center_abs, pos, tc, sum, weight);
	tile_tap(ivec2(-1,  1), 1.0, center_abs, pos, tc, sum, weight);
	tile_tap(ivec2( 1,  1), 1.0, center_abs, pos, tc, sum, weight);

	return sum / weight;
}

void main()
{
	ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
	ivec2 lid = ivec2(gl_LocalInvocationID.xy);

	// Fill shared memory tile with precomputed sum_quadrants.
	ivec2 tile_origin = ivec2(gl_WorkGroupID.xy) * 16 - BLUR_R;
	for (uint i = gl_LocalInvocationIndex; i < uint(TILE_W * TILE_W); i += 256u) {
		ivec2 tp = tile_origin + ivec2(int(i) % TILE_W, int(i) / TILE_W);
		s_tile[i] = (tp.x >= 0 && tp.x < u_world_size && tp.y >= 0 && tp.y < u_world_size)
			? sum_quadrants(tp) : vec3(0.0);
	}
	barrier();

	if (gid.x >= u_world_size || gid.y >= u_world_size) return;

	vec3 fluence;
	if (u_debug_mode >= 1 && u_debug_mode <= 4) {
		// Show a single quadrant, no blur.
		int rot = u_debug_mode - 1;
		int s = u_grid_size - 1;
		ivec2 grid_pos = gid * u_grid_size / u_world_size;
		ivec2 rp = grid_to_rotated(grid_pos, rot, s);
		vec3 r0 = F_load(rot, rp + ivec2(1, 0));
		if (u_cminus1 != 0) {
			Interval cminus1 = trace_cminus1(gid, rot);
			fluence = cminus1.rad + cminus1.trn * r0;
		} else {
			fluence = r0;
		}
	} else if (u_debug_mode == 5) {
		// Sum all quadrants with c-1 gathering, no blur.
		ivec2 tc = lid + BLUR_R;
		fluence = s_tile[tc.y * TILE_W + tc.x];
	} else {
		fluence = blur_tile(gid, lid + BLUR_R);
	}

	imageStore(u_fluence, gid, vec4(srgb_from_linear(fluence), 1.0));
}
