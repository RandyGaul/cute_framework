[](../header.md ':include')

<br>

CF uses SDL_GPU for rendering.
Since its [shader tools](https://github.com/libsdl-org/SDL_shader_tools) are still in early development, CF has its own shader tooling based on [glslang](https://github.com/KhronosGroup/glslang) as a temporary solution.

## Online compilation

By default, CF can compile GLSL 450 at runtime.
This feature is enabled through the CMake option `CF_RUNTIME_SHADER_COMPILATION` (`ON` by default).
Functions such as [`cf_make_shader_from_source`](/graphics/cf_make_shader_from_source.md) can be used for convenience.
This is how most shader samples are written.

With this option enabled, the build process will involve pulling in [glslang](https://github.com/KhronosGroup/glslang).
A Python 3.x installation is also required.
CF's own builtin shaders are also compiled everytime the program starts.

To remove the online compiler from CF, set `CF_RUNTIME_SHADER_COMPILATION` to `OFF`.
Take note that online compilation functions such as [`cf_make_shader_from_source`](/graphics/cf_make_shader_from_source.md) will always fail if this is the case.

## Offline compilation

If you have a lot of shaders and want to avoid runtime compilation overhead, CF provides its own offline compiler: `cute-shaderc`.

```
Usage: cute-shaderc [options] <input>
Compile GLSL into SPIRV bytecode and generate a C header for embedding.

--help             Print this message.
-I<dir>            Add directory to #include search path.
-type=<type>       The shader type. Valid values are:
                   * draw (default): Draw shader for `cf_make_draw_shader_from_bytecode`.
                   * vertex: Standalone vertex shader for `cf_make_shader_from_bytecode`.
                   * fragment: Standalone fragment shader for `cf_make_shader_from_bytecode`.
-oheader=<file>    Where to write the C header file.
                   Also requires -varname.
-varname=<file>    The variable name inside the C header.
-obytecode=<file>  (Optional) Where to write the raw SPIRV blob.
```

`cute-shaderc` can be used to precompile your shader code in to a C/C++ header.

`-oheader=` indicates where you want to output the header file.

`-varname=` indicates the name of the static variable of the type [`CF_ShaderBytecode`](/graphics/cf_shaderbytecode.md).
This variable will be defined in the generated header.
It can be passed to related shader functions (explained below).

The `-type=` flag indicates which type of shader you want to compile:

* `vertex` and `fragment` are for compiling [low level shaders](https://randygaul.github.io/cute_framework/#/topics/low_level_graphics?id=shaders).
  The result should be passed into [`cf_make_shader_from_bytecode`](/graphics/cf_make_shader_from_bytecode.md).
* `draw` is for compiling [custom draw shaders](https://randygaul.github.io/cute_framework/#/topics/drawing?id=shaders).
  The result should be passed into [`cf_make_draw_shader_from_bytecode`](/draw/cf_make_draw_shader_from_bytecode.md).

The `-I` flag will be explained in the "Shader inclusion" section below.

In case you need the raw SPIRV blob, `-obytecode=` can also be used.
Take note that this is only availble for shaders of type `vertex` or `fragment`.

## Working with `cute-shaderc`

To detect compilation setting, CF defines the macro `CF_RUNTIME_SHADER_COMPILATION` when online compilation is enabled.
In order to make your code compatible with both options (`ON` and `OFF`), use the following idiom:

```c
#ifndef CF_RUNTIME_SHADER_COMPILATION  // When runtime shader compilation is disabled
#include "custom_draw_shd.h"  // Include the header generated by cute-shaderc
#endif

int main() {
#ifdef CF_RUNTIME_SHADER_COMPILATION // If runtime compilation is enabled
    // Load shader from disk
    cf_shader_directory("/shaders");
    CF_Shader custom_draw_shader = cf_make_draw_shader("custom_draw.shd");
#else // If runtime compilation is disabled
    // Use precompiled shader
    CF_Shader custom_draw_shader = cf_make_draw_shader_from_bytecode(s_custom_draw_shd);
#endif
}
```

Thus, during development, you can edit the shader source file directly for faster iteration.
When you need to ship, your game will use the precompiled version.

In order to keep the generated header in sync, add the following into your `CMakeLists.txt`:

```cmake
if (NOT CF_RUNTIME_SHADER_COMPILATION)
    add_custom_command(
        # Replace with where you want to output the header
        OUTPUT ${CMAKE_CURRENT_SOURCE_DIR}/src/custom_draw_shd.h
        COMMAND cute-shaderc  # The path is set automatically by CMake
            # Replace with your shader directory
            -I${CMAKE_CURRENT_SOURCE_DIR}/shaders
            # Other types are possible
            -type=draw
            # What you want the variable name to be
            -varname=s_flash_shd_bytecode
            # Repeat the path above
            -oheader=${CMAKE_CURRENT_SOURCE_DIR}/src/custom_draw_shd.h
            # Replace with path to the shader file
            ${CMAKE_CURRENT_SOURCE_DIR}/shaders/custom_draw.shd
        DEPENDS shaders/custom_draw.shd  # Rebuild when the shader source change
        DEPENDS cute-shaderc  # Rebuild when the compiler is updated
    )
endif ()

# Make sure that your program depends on the generated header
set(SOURCES
    # Other source files
    src/main.c
    # Generated headers
    src/custom_draw_shd.h
)
add_executable(my_game SOURCES)
```

## Minimal build

If you do not need custom shaders, set both `CF_RUNTIME_SHADER_COMPILATION` and `CF_CUTE_SHADERC` to `OFF`.
Both online and offline compilers will not be built.
This will reduce build time.
You can still use all other CF's features.

This is also possible if you already have a prebuilt copy of `cute-shaderc`.

## Shader inclusion

To make reusable utility functions, shaders can include each other with the `#include` directive.

"Include guard", usually seen in C/C++, is not needed.
Each file will only be included once and subsequent inclusions are ignored.

With online compilation, the include directory can be set with [`cf_shader_directory`](/graphics/cf_shader_directory.md).
For example: `cf_shader_directory("/shaders");`.
Take note that this is a path in the [VFS](/topics/virtual_file_system.md), hence, the leading slash ('/').

With offline compilation, the include directory is set with the `-I` flag.
For example: `cute-shaderc -Ishaders -o src/my_shader_shd.h my_shader.shd`.
Take note that this is a path in your actual filesystem.
It is relative to where you run the command.
When using CMake, prefix the path with `${CMAKE_CURRENT_SOURCE_DIR}` to make it independent of the build directory.

In both cases, whenever `#include` is encountered, the specified directory will be searched.
Each included shader can, in turn, include other shaders.
Take note that while two styles of includes are accepted: "system" (i.e: `#include <shader.shd>`) and "local" (i.e: `#include "shader.shd"`), they are both treated as "system" include.
In other words, included shaders are **always** searched in the shader directory regardless of where the including shader is located.
This is to provide consistent behaviour for both offline compilation from a source file and online compilation from a runtime string.

CF also provides several builtin utility modules: `gamma.shd`, `distance.shd`, `smooth_uv.shd`, `blend.shd`.
These can always be `#include`-d by your shader without setting the include path.

## Draw shader quirks

Due to the way [custom draw shaders](https://randygaul.github.io/cute_framework/#/topics/drawing?id=shaders) are compiled, any errors in your shader will be reported as being from `shader_stub.shd`.
Do not look for this file and just take it as the errors are coming from whatever shader you are trying to compile.

## Migrating to SDL_GPU official shader tool

The current shader tooling is temporary until SDL's own shader tooling is mature enough.
It is still in early development so we do not know what will change.
To ensure as little friction as possible during migration, the following practice is advised.

The `CF_ShaderBytecode` struct, whether coming from [`cf_compile_shader_to_bytecode`](/graphics/cf_compile_shader_to_bytecode.md) or the `cute-shaderc` compiler should be treated as opaque.
It should not be modified in anyway and only passed verbatim to related functions: [`cf_make_shader_from_bytecode`](/graphics/cf_make_shader_from_bytecode.md) and [`cf_make_draw_shader_from_bytecode`](/draw/cf_make_draw_shader_from_bytecode.md).
There is no guarantee on how the inner structure may change but the signature of the above functions will remain the same regardless of compilation backend.
In other words, the API should remain stable at source level but there is no guarantee on the ABI.

`cute-shaderc` will still be provided as an offline compilation tool.
Its various flags and their behaviours will remain the same.
The generated header will still declare a variable of the type [`CF_ShaderBytecode`](/graphics/cf_shaderbytecode.md).
The actual content of the output, however, might change with compilation backend.

Beyond the above, binary shader content or even the shading language syntax might not be compatible when we adopt SDL's official shader tooling.
This section will be updated when further information is available.
